<div style="display: block; text-align: left;"><a href="AutoCompleteTextBox.jpg" imageanchor="1"><img src="AutoCompleteTextBox.jpg" border="0"></a></div>
<br>
<h2>Introduction </h2>
<p>This Article demos how to create a textbox.which can suggest items in runtime based on input, in this case, disk drive folders.<br>
</p>
<h2>Background </h2>
There's a number of AutoComplete TextBox implementation around, however, some dont support data binding, others dont support runtime items polling.&nbsp; <br>
After some Googling, I decided to write my own instead of continue looking for one.<br>
<br>
<h2>My Design process </h2>
My first design is based on ComboBox, I copy the default template and remove the drop down button and develop from that, it doesnt work because combobox have it's own autocomplete mechanism which will change the selection of textbox when Items is changed, it's not designed for Items that change at realtime.
<br>
<br>
So the second design is based on TextBox, I create the following style :<br>

<pre><span style="color: rgb(102, 102, 102);">&lt;Style x:Key="</span><b style="color: rgb(102, 102, 102);">autoCompleteTextBox</b><span style="color: rgb(102, 102, 102);">" TargetType="{x:Type TextBox}"&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  &lt;Setter Property="Template"&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    &lt;Setter.Value&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      &lt;ControlTemplate TargetType="{x:Type TextBoxBase}"&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">        &lt;Grid x:Name="root"&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">          &lt;ScrollViewer Margin="0" x:Name="</span><b style="color: rgb(102, 102, 102);">PART_ContentHost</b><span style="color: rgb(102, 102, 102);">"/&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">          &lt;Popup x:Name="</span><b style="color: rgb(102, 102, 102);">PART_Popup</b><span style="color: rgb(102, 102, 102);">" AllowsTransparency="true" Placement="Bottom" IsOpen="False"  </span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">                        PopupAnimation="{DynamicResource {x:Static SystemParameters.ComboBoxPopupAnimationKey}}"&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">                &lt;ListBox x:Name="</span><b style="color: rgb(102, 102, 102);">PART_ItemList</b><span style="color: rgb(102, 102, 102);">" SnapsToDevicePixels="{TemplateBinding SnapsToDevicePixels}"                                                     </span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">                         VerticalContentAlignment="Stretch" HorizontalContentAlignment="Stretch"</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">                         KeyboardNavigation.DirectionalNavigation="Contained" /&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">          &lt;/Popup&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">        &lt;/Grid&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      &lt;/ControlTemplate&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    &lt;/Setter.Value&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">   &lt;/Setter&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">&lt;/Style&gt;</span><br></pre>
<b>and then create a custom control and hook the style to it :&nbsp; </b><br>
<pre><span style="color: rgb(102, 102, 102);">&lt;TextBox x:Class="QuickZip.Controls.SelectFolderTextBox" Style="{DynamicResource </span><b style="color: rgb(102, 102, 102);">autoCompleteTextBox</b><span style="color: rgb(102, 102, 102);">}" &nbsp;&gt; ... &lt;/TextBox&gt;</span><br></pre>
PART_ContentHost is actually a control that TextBoxView, it is required for TextBox template (with that name), or the control won't function, the another two part (PART_Popup and PART_ItemList) is defined so I can use them in the custom control : <br>
<pre><span style="color: rgb(102, 102, 102);">public partial class SelectFolderTextBox : TextBox</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">{</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">   Popup Popup { get { return this.Template.FindName("PART_Popup", this) as Popup; } }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">   ListBox ItemList { get { return this.Template.FindName("PART_ItemList", this) as ListBox; } }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">   ScrollViewer Host { get { return this.Template.FindName("PART_ContentHost", this) as ScrollViewer; } }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">   UIElement TextBoxView { get { foreach (object o in LogicalTreeHelper.GetChildren(Host)) return o as UIElement; return null; } }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">   ....</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">}</span><br><div style="display: block; text-align: left;"><a href="label.jpg" imageanchor="1"><img src="label.jpg" border="0"></a></div><br></pre>
If text is changed, the suggestion item list is updated as well :&nbsp; <br>
<pre style="color: rgb(102, 102, 102);">protected override void OnTextChanged(TextChangedEventArgs e)<br>{<br>  if (_loaded)<br>  {                                <br>    try<br>    {<br>      if (lastPath != Path.GetDirectoryName(this.Text))      <br>      {<br>        lastPath = Path.GetDirectoryName(this.Text);<br>        string[] paths = Lookup(this.Text);<br><br>        ItemList.Items.Clear();<br>        foreach (string path in paths)<br>          if (!(String.Equals(path, this.Text, StringComparison.CurrentCultureIgnoreCase)))<br>            ItemList.Items.Add(path);<br>      }                        <br>                            <br>      Popup.IsOpen = true;<br>      <br>      //I added a Filter so Directory polling is only called once per directory, thus improve speed<br>      ItemList.Items.Filter = p =&gt;<br>      {<br>        string path = p as string;<br>        return path.StartsWith(this.Text, StringComparison.CurrentCultureIgnoreCase) &amp;&amp;<br>          !(String.Equals(path, this.Text, StringComparison.CurrentCultureIgnoreCase));<br>      };<br>    }<br>    catch<br>    {<br>    }                <br>  }<br>}</pre>
<br>
<br>
<b>A number of handlers is then defined :</b><br>
<br>
<pre style="color: rgb(102, 102, 102);">public override void OnApplyTemplate()<br>{<br>  base.OnApplyTemplate();<br>  _loaded = true;<br>  this.KeyDown += new KeyEventHandler(AutoCompleteTextBox_KeyDown);<br>  this.PreviewKeyDown += new KeyEventHandler(AutoCompleteTextBox_PreviewKeyDown);            <br>  ItemList.PreviewMouseDown += new MouseButtonEventHandler(ItemList_PreviewMouseDown);<br>  ItemList.KeyDown += new KeyEventHandler(ItemList_KeyDown);<br>}</pre>
<b>AutoCompleteTextBox_PreviewKeyDown</b> : <br>
if user press down button, the textbox will move focus to the Listbox, so the user can choose an item from it, this is placed in PreviewKeyDown instead of KeyDown because TextBox's mechanism will consume the event before it reach KeyDown if the button is down button.<br>
<pre style="color: rgb(102, 102, 102);">void AutoCompleteTextBox_PreviewKeyDown(object sender, KeyEventArgs e)<br>{<br>  if (e.Key == Key.Down &amp;&amp; ItemList.Items.Count &gt; 0 &amp;&amp; !(e.OriginalSource is ListBoxItem))<br>  {<br>    ItemList.Focus();<br>    ItemList.SelectedIndex = 0;<br>    ListBoxItem lbi = ItemList.ItemContainerGenerator.ContainerFromIndex(ItemList.SelectedIndex) as ListBoxItem;<br>    lbi.Focus();<br>    e.Handled = true;<br>  }<br>}</pre>
<pre><b>AutoCompleteTextBox_KeyDown</b> <br>if user press &lt;enter&gt; button, the textbox will close the popup and update the binding.<br><br><span style="color: rgb(102, 102, 102);">void AutoCompleteTextBox_KeyDown(object sender, KeyEventArgs e)</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">{           </span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  if (e.Key == Key.Enter)</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  {</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    Popup.IsOpen = false;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    updateSource();</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">}</span><br><br><b>ItemList_PreviewMouseDown</b> and <b>ItemList_PreviewMouseDown</b><br>if user press &lt;enter&gt; button (or select by mouse), the text textbox will be updated with ListBox.SelectedValue, and then update the binding.<br><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">void ItemList_KeyDown(object sender, KeyEventArgs e)</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">{</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  if (e.OriginalSource is ListBoxItem)</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  {           </span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    ListBoxItem tb = e.OriginalSource as ListBoxItem;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    Text = (tb.Content as string);</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    if (e.Key == Key.Enter)</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    {                    </span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      Popup.IsOpen = false;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      updateSource();</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">                </span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">}</span><br><br><span style="color: rgb(102, 102, 102);">void ItemList_PreviewMouseDown(object sender, MouseButtonEventArgs e)</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">{</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  if (e.LeftButton == MouseButtonState.Pressed)</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  {          {</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    TextBlock tb = e.OriginalSource as TextBlock;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    if (tb != null)</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    {</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      Text = tb.Text;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      updateSource();</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      Popup.IsOpen = false;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      e.Handled = true;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  }</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">}</span><br></pre>

updateSource is required because I bound text's UpdateSourceTrigger as Explicit, if updateSource is not called it wont update the text :<br>
<pre style="color: rgb(102, 102, 102);">void updateSource()<br>{<br>  if (this.GetBindingExpression(TextBox.TextProperty) != null)<br>    this.GetBindingExpression(TextBox.TextProperty).UpdateSource();<br>}</pre>
The component is working now, but if you want to add validation as well, read below :&nbsp; <br>
<hr size="2" width="100%">
<b>To support validation, a Validation Rule is written : </b><br>
<p style="color: rgb(0, 0, 0);" lang="xml">If the path is not
found or an exception raised when looking up, it will return
ValidationResult false, the error will be accessed by using the
attached properties Validation.Errors and Validation.HasError. </p>
<pre style="color: rgb(102, 102, 102);">public class DirectoryExistsRule : ValidationRule<br>{<br>  public static DirectoryExistsRule Instance = new DirectoryExistsRule();<br><br>  public override ValidationResult Validate(object value, System.Globalization.CultureInfo cultureInfo)<br>  {<br>    try<br>    {<br>      if (!(value is string))<br>        return new ValidationResult(false, "InvalidPath");<br><br>      if (!Directory.Exists((string)value))<br>        return new ValidationResult(false, "Path Not Found");                                        <br>    }<br>    catch (Exception ex)<br>    {<br>      return new ValidationResult(false, "Invalid Path");<br>    }<br>    return new ValidationResult(true, null);<br>  }<br>}</pre>
<br>
and change the binding : (to use the created Validation rule, noted that UpdateSourceTrigger is Explicit. )<br>
<pre style="color: rgb(102, 102, 102);">&lt;local:SelectFolderTextBox  x:Name="stb" DockPanel.Dock="Bottom" Margin="4,0,0,0"&gt;<br>  &lt;local:SelectFolderTextBox.Text&gt;<br>    &lt;Binding Path="Text" UpdateSourceTrigger="Explicit" &gt;<br>      &lt;Binding.ValidationRules&gt;<br>        <b>&lt;t:DirectoryExistsRule /&gt;</b><br>      &lt;/Binding.ValidationRules&gt;<br>    &lt;/Binding&gt;<br>  &lt;/local:SelectFolderTextBox.Text&gt;<br>&lt;/local:SelectFolderTextBox&gt;</pre>
Now the textbox show a red border if directory not exists. As a red border isnt clear enough, we can change the behavior : <br>
<br>
to disable the default red border: <br>
<pre><span style="color: rgb(102, 102, 102);">&lt;Style x:Key="</span><b style="color: rgb(102, 102, 102);">autoCompleteTextBox</b><span style="color: rgb(102, 102, 102);">" TargetType="{x:Type TextBox}"&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  &lt;...&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  &lt;Setter Property="Validation.ErrorTemplate"&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    &lt;Setter.Value&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      &lt;ControlTemplate &gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">        &lt;</span><b style="color: rgb(102, 102, 102);">AdornedElementPlaceholder </b><span style="color: rgb(102, 102, 102);">/&gt; &lt;!-- The TextBox Element --&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">      &lt;/ControlTemplate&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    &lt;/Setter.Value&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">  &lt;/Setter&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">&lt;/Style&gt;</span><br></pre>
then change the control template, which will show the dockWarning when Validation.HasError :&nbsp; 
<pre><span style="color: rgb(102, 102, 102);">&lt;ControlTemplate TargetType="{x:Type TextBoxBase}"&gt;</span><br>  <span style="color: rgb(0, 0, 255);">&lt;Border Name="Border" CornerRadius="2"  Background="{StaticResource WindowBackgroundBrush}" </span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">       BorderBrush="{StaticResource SolidBorderBrush}" BorderThickness="1" Padding="1" &gt;</span><br>    <span style="color: rgb(102, 102, 102);">&lt;Grid x:Name="root"&gt;</span><br>      &lt;...&gt; <br><span style="color: rgb(102, 102, 102);">      <span style="color: rgb(0, 0, 255);">&lt;DockPanel x:Name="<b>dockWarning</b>" Visibility="Collapsed"  LastChildFill="False" &gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">      &lt;Border DockPanel.Dock="Right"  BorderBrush="Red" Background="Red" BorderThickness="2"  CornerRadius="2,2,0,0"&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">        &lt;TextBlock x:Name="txtWarning" DockPanel.Dock="Right" Text="{TemplateBinding ToolTip}" VerticalAlignment="Top" </span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">                   Background="Red" Foreground="White"  FontSize="10" /&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">          &lt;Border.RenderTransform&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">            &lt;TranslateTransform X="2" Y="{Binding ElementName=dockWarning, Path=ActualHeight,</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">                                 Converter={x:Static t:InvertSignConverter.Instance}}"/&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">            &lt;!--</span></span><span style="color: rgb(102, 102, 102);"><span style="color: rgb(0, 0, 255);">TranslateTransform move the border to upper right corner, outside the TextBox</span></span><span style="color: rgb(102, 102, 102);"><span style="color: rgb(0, 0, 255);"> --&gt;<br></span></span><span style="color: rgb(102, 102, 102);"><span style="color: rgb(0, 0, 255);">            &lt;!--</span></span><span style="color: rgb(0, 0, 255);">InvertSignConverter</span><span style="color: rgb(102, 102, 102);"><span style="color: rgb(0, 0, 255);"> is a IValueConverter that change + to -, - to + --&gt;</span></span><br><span style="color: rgb(102, 102, 102);"><span style="color: rgb(0, 0, 255);">          &lt;/Border.RenderTransform&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">        &lt;/Border&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 0);"><span style="color: rgb(0, 0, 255);">      &lt;/DockPanel&gt;</span>  </span></span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">    &lt;/Grid&gt;</span><br>  <span style="color: rgb(0, 0, 255);">&lt;/Border&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">  &lt;ControlTemplate.Triggers&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">    &lt;MultiTrigger&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">      &lt;MultiTrigger.Conditions&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">        &lt;Condition Property="</span><b style="color: rgb(0, 0, 255);">Validation.HasError</b><span style="color: rgb(0, 0, 255);">" Value="true" /&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">        &lt;Condition SourceName="</span><b style="color: rgb(0, 0, 255);">PART_Popup</b><span style="color: rgb(0, 0, 255);">" Property="IsOpen" Value="False" /&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">      &lt;/MultiTrigger.Conditions&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">      &lt;Setter Property="ToolTip" Value="{Binding RelativeSource={RelativeSource Self}, Path=(Validation.Errors)[0].ErrorContent}"/&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">      &lt;Setter TargetName="</span><b style="color: rgb(0, 0, 255);">dockWarning</b><span style="color: rgb(0, 0, 255);">" Property="Visibility" Value="Visible" /&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">      &lt;Setter TargetName="Border" Property="BorderThickness" Value="2" /&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">      &lt;Setter TargetName="Border" Property="Padding" Value="0" /&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">      &lt;Setter TargetName="Border" Property="BorderBrush" Value="Red" /&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">    &lt;/MultiTrigger&gt;</span><br style="color: rgb(0, 0, 255);"><span style="color: rgb(0, 0, 255);">  &lt;/ControlTemplate.Triggers&gt;</span><br style="color: rgb(102, 102, 102);"><span style="color: rgb(102, 102, 102);">&lt;/ControlTemplate&gt;</span></pre>
<br>
<h2>History</h2>
<p>22-12-08 Initial version <br>
<br>
</p>
<h2>License</h2>
			

This article, along with any associated source code and files, is licensed under <a href="http://www.opensource.org/licenses/lgpl-license.php">The GNU Lesser General Public License</a><br>
